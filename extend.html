<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>How to Build Mimosa Modules - Mimosa</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Mimosa is extensible, making it easy to add your own functionality via modules."><link rel="stylesheet" href="public/stylesheets/site.css"><link rel="shortcut icon" href="public/images/favicon.ico"></head><body class="extend-page" data-spy="scroll" data-target=".left-nav" data-offset="90"><nav class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#site-navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="./index.html">Mimosa</a></div><div id="site-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="./started.html">Get Started</a></li><li><a href="./commands.html">Commands</a></li><li><a href="./modules.html">Modules</a></li><li class="active"><a href="./extend.html">Extend</a></li><li><a href="./configuration.html">Config</a></li><li><a href="./about.html">FAQ/Tips</a></li><li><a href="http://dbashford.github.io">Blog</a></li></ul></div></div></nav><div class="container-fluid"><header class="jumbotron"><div class="container"><h1>Building A Mimosa Module</h1><p class="lead">Plug custom functionality into Mimosa</p></div></header></div><div class="container"><div class="row"><div class="col-md-2 col-sm-3 left-nav"><ul class="nav nav-pills nav-stacked" data-spy="affix" data-offset-top="195"><li><a href="#createsummary" title="Getting started with configuration">Summary</a></li><li><a href="#createdetail" title="Mimosa module details">Details</a></li><li><a href="#interface" title="Mimosa's Module Interface">Module Interface</a></li><li><a href="#registering" title="Registering a module">Registration</a></li><li><a href="#execution" title="Module execution">Execution</a></li><li><a href="#commands" title="Custom Commands">Custom Commands</a></li><li><a href="#logging" title="Module execution">Logging</a></li><li><a href="#install" title="Module execution">Installation</a></li></ul></div><div class="col-md-10 col-sm-9"><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="createsummary">Creating a Module: Summarized</h2></div><div class="panel-body"><p>The following is a quick tutorial on how to build a simple module. You could also visit this <a href="http://dbashford.github.io/making-a-mimosa-module/index.html">post on the blog</a> which covers the same topic.</p><p>The best way to figure out how to create a module is to look at an existing one. The <a href="https://github.com/dbashford/mimosa-minify-html">mimosa-minify-html</a> module is a simple module to understand: it exists to minify HTML files, making them as small as possible without removing capability or content.</p><h3>Mimosa module's exports</h3><p>Mimosa expects to find certain things in a module's interface.</p><p>At the bottom of the <a href="https://github.com/dbashford/mimosa-minify-html/blob/7c547af5603ce4dcaa3cb688bc2d334755988ec6/src/index.js#L39-L43">index file</a> is the <code class="option">module.exports</code> object. That object defines the module interface.</p><p>Working from the bottom up:</p><div class="row"><div class="col-md-6"><ul class="top-split"><li><code class="option">validate</code> is optional, but if it exists it is called to validate a user's configuration. The <a href="https://github.com/dbashford/mimosa-minify-html/blob/7c547af5603ce4dcaa3cb688bc2d334755988ec6/src/config.js#L11-L19">mimosa-minify-html validate</a> is small. One thing it does is verify that the mimosa-config's <code class="option">minifyHtml</code> object is an <code class="option">object</code>. If it wasn't <code class="option">validate</code> would return an error, Mimosa would not start, and the error message would be displayed.</li></ul></div><div class="col-md-6"><pre>module.exports = {
  registration: registration,
  defaults: config.defaults,
  validate: config.validate
}</pre></div></div><ul><li><code class="option">defaults</code>, again optional, is how the module lets Mimosa know its default configuration. <a href="https://github.com/dbashford/mimosa-minify-html/blob/7c547af5603ce4dcaa3cb688bc2d334755988ec6/src/config.js#L3-L9">mimosa-minify-html's defaults</a> returns a simple object.</li><li><code class="option">registration</code> is how a module informs Mimosa what code to call and when.</li></ul><h3>Registering a module</h3><p>A module needs to register itself with Mimosa so that Mimosa knows what functionality to invoke and when to invoke it.</p><p>Lets break down a single line of <a href="https://github.com/dbashford/mimosa-minify-html/blob/7c547af5603ce4dcaa3cb688bc2d334755988ec6/src/index.js#L35">mimosa-minify-html's registration</a>.</p><div class="row"><div class="col-md-6"><ul class="top-split"><li><code class="option">register</code> is a function provided by Mimosa to execute the registration.</li><li>The entries in the <code class="option">['add', 'update', 'buildFile']</code> array are Mimosa workflows. mimosa-minify-html needs to be invoked to minify HTML when an HTML file is built (when Mimosa starts), added (after it starts), or updated (while it is running).</li></ul></div><div class="col-md-6"><pre>register(
  [ "add", "update", "buildFile"],
  "afterCompile",
  _execute,
  [ "html", "htm" ]
);</pre></div></div><ul><li><code class="option">'afterCompile'</code> indicates what workflow step to call the module's code. In this case right before a file is written its HTML needs to be minified.</li><li><code class="option">_execute</code> is the function to invoke in order to perform the minification of the file being processed.</li><li><code class="option">[ "html", "htm" ]</code> indicates the function should only be called for HTML based extensions.</li></ul><h3>Module execution</h3><p>When Mimosa execute the functionality of a module, Mimosa passes along certain objects/functions</p><p>Lets look at the first few lines of the <a href="https://github.com/dbashford/mimosa-minify-html/blob/7c547af5603ce4dcaa3cb688bc2d334755988ec6/src/index.js#L6-L7">_execute</a> function.</p><div class="row"><div class="col-md-4"><p>Functions called during Mimosa's workflows are handed three objects.</p><ul class="top-split"><li>The resolved mimosa-config, including the configuration for the module being invoked.</li></ul></div><div class="col-md-8"><pre>var _execute = function ( mimosaConfig, options, next ) {
  if ( options.files && options.files.length ) {
    ...</pre></div></div><ul><li>An <code class="option">options</code> object which contains the information regarding the current file(s) being processed.</li><li>A <code class="option">next</code> callback which informs Mimosa it can continue on to the next step in the workflow.</li></ul><p>The <code class="option">options</code> object contains a <code class="option">files</code> array which contains references to the file(s) being processed including their file path and file text. The code above does a check to see if there are any files to process. If there isn't, there is nothing to minify, so it calls the <code class="option">next</code> callback and exits.</p><p>Finally, how does one pass information along? The mimosa-minify-html module doesn't write anything, it just <a href="https://github.com/dbashford/mimosa-minify-html/blob/3589ae3113286cdb7243107ba4c4a62dffa93db1/src/index.js#L14">minifies text</a> that is already available in the <code class="option">files</code>array and then stores the result on the file object itself. Other modules are responsible for writing the file objects once processing for the file has finished.</p><p>Hopefully that is a simple starter to get you going building your own module.</p><p>Exhaustive details follow.</p></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="createdetail">Creating a Module: The Details</h2></div><div class="panel-body"><h3>Where to start?</h3><p>First, check out the <a href="http://dbashford.github.io/making-a-mimosa-module/index.html">blog post</a>, and if you still have questions, come back here for more details.</p><p>By far the easiest way to create a new module is to start with an existing one. There are many modules available on GitHub. Pick one that does something somewhat similar to what you want to do and make tiny modifications to it.</p><p>There are also module skeletons. <code>mimosa skel:new</code> can be used to pull in a skeleton. There are two available in the skeleton registry <code>mimosa-module-javascript</code> and <code>mimosa-module-coffeescript</code>. So, for instance, <code>mimosa skel:new mimosa-module-javascript</code> will pull in the JavaScript Mimosa module skeleton.</p><p>The only hard and fast rule with Mimosa modules is that when they are created they must be prefixed with 'mimosa-'. This makes them easy to find if someone else wants to use them, but also differentiates Mimosa's modules from all of the libraries both in <a href="https://npmjs.org/">NPM</a> and inside Mimosa. So you'll want to make sure that you keep the name of the module prefixed.</p><h3>What does a skeleton give me?</h3><p>The module skeletons provide a group of files to get module development started.</p><ul><li><code>package.json</code>: Those familiar with node.js recognize this file. This defines all sorts of metadata about a node project: the project name, dependencies, repo location, a description, and more. When a project is published to <a href="https://npmjs.org/">NPM</a>, NPM expects the <code>package.json</code> to be present. The <code>package.json</code> that Mimosa provides needs some editing. Many of the fields inside of it are placeholders and should be changed before publishing.</li><li><code>index.js</code>/<code>index.coffee</code>: This highly commented file defines a module's interface to Mimosa. Mimosa will use this file to execute a module's functionality. How a module is structured is entirely up to the developer, as long as the functions Mimosa expects are exported in the <code>index</code> file.</li><li><code>config.js</code>/<code>config.coffee</code>: This file is also highly commented and contains two functions that might need to be implemented: a function that returns the default configuration and a function that validates a user's configuration for the module. Mimosa calls these functions at different times. If a module has no configuration at all, the functions and the file can be removed, or they can be left and commented out in case configuration might be introduced later.</li><li>A <code>docs</code> folder: Using a tool called <a href="http://jashkenas.github.com/docco/">Docco</a> the comments in the <code>config</code> and <code>index</code> files have been turned into easy to read web pages, with comments alongside code. This is the real place to start. Read through the the Docco pages and get comfy with the concepts.</li><li>A starter <code>README.md</code> with a few things filled out.</li></ul></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="interface">Mimosa's module interface</h2></div><div class="panel-body"><p>At different times, Mimosa will attempt to execute five different functions in a module. All of the functions are optional.</p><h3>registerCommand(program, retrieveConfig)<br>registerCommand(program, debug, retrieveConfig)</h3><p>The <code>registerCommand</code> function is self-explanatory. This function is used to register new Mimosa commands.</p><p>The arguments passed in are:</p><ul><li><code>program</code>: A <a href="https://github.com/visionmedia/commander.js/">commander</a> <code>program</code> object. Use this object to register commands, help text, flags, and the command's callback.</li><li><code>debug</code>: A boolean to indicate if Mimosa's debug mode should be turned on.</li><li><code>retrieveConfig</code>: A callback function that a module can use to execute a Mimosa <code>clean</code> and <code>build</code> and get the full <code>mimosa-config</code> should it be needed. This function takes two parameters, a flag to indicate if a build should be run before executing the command, and a callback function to execute the command module's code. That callback is passed the full <code>mimosa-config</code>.</li></ul><p>The <a href="https://github.com/dbashford/mimosa-bower/blob/3df656086d84d8deee7cb244c3a7c0918d17cda3/src/index.coffee#L55-L78">mimosa-bower</a> module is a good example module for how to add a command to Mimosa. It adds three commands, <code>bower</code>, <code>bower:install</code> and <code>bower:clean</code>.</p><h3>defaults()</h3><div class="row"><div class="col-md-6"><p>A module's <code>defaults</code> function is called when Mimosa starts up and is used to assemble the configuration used by Mimosa. <code>defaults</code> should return a JavaScript object that is the default configuration for the module. That default configuration is merged with the user provided configuration to establish the full <code>mimosa-config</code>.</p><p>If a module doesn't have its own configuration, then this function does not need to be implemented.</p></div><div class="col-md-6"><pre>exports.defaults = function() {
  return {
    minifyHtml: {
      options: {}
    }
  };
};</pre></div></div><h3>validate(mimosaConfig, validators)</h3><p>A module's <code>validate</code> function is called when Mimosa starts up and after Mimosa has put together the full <code>mimosa-config</code>. That full config is passed to the <code>validate</code> function of all modules and each module has the opportunity to ensure that the config settings are valid. This function should return an array of strings. Each string represents an error that the module has found with the config. If a module return any errors, Mimosa will print the errors and exit to give the user a chance to update the config.</p><p>The <code>validate</code> function is also passed, as the second parameter, an object containing a collection of validation and utility functions. The best way to learn what those functions are is to <a href="https://github.com/dbashford/validatemimosa/blob/master/src/index.coffee">check the source</a>.</p><p>If there are no errors, return an empty array. If there is no config to validate, then do not implement the function.</p><pre>exports.validate = function( mimosaConfig, validators ) {
  var errs = [], mHtml = mimosaConfig.minifyHtml;
  if (validators.ifExistsIsObject(errs, "minifyHtml config", mHtml)) {
    validators.ifExistsIsObject(errs, "minifyHtml.options", mHtml.options);
  }
  return errs;
};</pre><p>This function is also commonly where configuration manipulation and normalization takes place. For instance, this is a good place to turn relative paths into absolute ones so your module is dealing entirely with absolute paths in the config.</p><h3>registration(mimosaConfig, register)</h3><p>The <code>registration</code> function is the most important function of a module. This function is called during Mimosa's startup and it allows a module to bind to one or many steps in a Mimosa workflow. Inside this function is where a module tells Mimosa to call its functions at certain times.</p><pre>var registration = function ( mimosaConfig, register ) {
  if ( mimosaConfig.isMinify ) {
    register(
      [ "add", "update", "buildFile"],
      "afterCompile",
      _execute,
      [ "html", "htm" ]
    );
  }
};</pre><p>The arguments passed in are:</p><ul><li><code>mimosaConfig</code>: The full <code>mimosa-config</code> including added flags to indicate what sort of Mimosa command is being run (like isForceClean), and an added list of extensions being used by the application. A developer may decide based on the flags in the config to not register anything, which is fine. In the case of the minification example here, if the isMinify flag isn't turned on then the module doesn't register itself.</li><li><code>register</code>: This is a function handed to a module as a means to register a module with Mimosa. More information about how to use this register function follows in the next section.</li></ul></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="registering">Module Registration</h2></div><div class="panel-body"><p>As mentioned in a previous section, a module should implement a <code>registration</code> function that Mimosa calls when it starts up. When Mimosa calls the module's <code>registration</code> function, Mimosa passes the enriched <code>mimosa-config</code> and a <code>register</code> callback. The <code>register</code> callback is what a module uses to inform Mimosa what function in the module to call and under what circumstances to call it. The <code>register</code> function takes the following four parameters:</p><pre>register(['add','update','buildFile'],      'afterCompile', _minifyJS, e.javascript);
register(['add','update','buildExtension'], 'beforeWrite',  _minifyJS, e.template);</pre><ol><li>A list of workflows, an array of strings. Pick one-to-many workflows depending on the sort of task the module accomplishes. The possible values, like buildFile, buildExtension, postBuild, add, update, and remove, are explained below.</li><li>A workflow step, a string. A workflow step for the selected workflows. For example, for the 'update' workflow, a module's code might be executed 'afterCompile'. The list of steps for each workflow is explained below.</li><li>Module callback, a function. This is the function Mimosa will call when processing reaches the workflow(s) and step called out in the previous parameters.</li><li>An optional array of extensions upon which to execute the callback. If the file or extension being processed doesn't match one of these extensions, the callback will not be executed. The extensions refer to the original extension of the file being processed, so in the case of a CoffeeScript file it would be 'coffee' and not 'js'. The passed in <code>mimosaConfig</code> object has an <code>extensions</code> object a module can use to cover all of the desired extensions. The <code>extensions</code> object has 4 properties: <code>javascript</code>, <code>css</code>, <code>template</code>, and <code>copy</code>. If no extensions are provided, Mimosa will send all files/extensions through the module.</li></ol><p>Notice that the register function is executed multiple times. There is nothing stopping a module from registering multiple times for multiple workflows.</p><h3>Workflows <small>categorizing application lifecycles</small></h3><p>A workflow is a set of steps an asset, a group of assets, or an application can go through. There are three groups of workflows that correspond to the three main processing types for an applciation: build, watch and clean.</p><div class="row"><div class="col-md-4"><h4>Build Workflows</h4><p>Modules registered to take place during the build workflows perform project builds. The build workflows all occur in order during Mimosa's startup. <code>preBuild</code> occurs first, followed by <code>buildFile</code>, <code>buildExtension</code>, and <code>postBuild</code>.</p><h5>preBuild</h5><p><code>preBuild</code> is processed before any asset is handled. This is the workflow for preparing the file system and moving files around in preparation for individual file processing.</p><h5>buildFile</h5><p>During <code>buildFile</code> each file in the configured <code>watch.sourceDir</code> is individually processed. This step is when, for instance, CoffeeScript files are compiled to JavaScript and written to <code>watch.compiledDir</code>. It is also when images are copied to the <code>watch.compiledDir</code>.</p><p>Some assets, like micro-template files (Handlebars or Dust) and CSS preprocessor files (SASS or LESS) are not processed during this step as they, during startup, need to be dealt with as a group rather than individually.</p><h5>buildExtension</h5><p>After all of the assets are processed individually, <code>buildExtension</code> makes another pass through all the assets, but this time to handle extension-wide processing. Now is when Mimosa handles the file types that need to be managed as a group like micro-templates and CSS preprocessors.</p><p>For instance, if a project uses SASS, then it might have 20 includes/partials that result in two top-level files. Mimosa will process all 20 files at once and recognize that only two files need to be compiled.</p><h5>postBuild</h5><p>After the extensions are finished, individual asset handling is finished. <code>postBuild</code> is when post asset completion tasks, like asset optimization, take place. <code>postBuild</code> is also when servers are started. If a module was being built for something like installing the app to Heroku, then <code>postBuild</code> is a candidate workflow.</p></div><div class="col-md-4"><h4>Watch Workflows</h4><p>If <code>mimosa build</code> was executed, then after <code>postBuild</code> is done, Mimosa exits. If <code>mimosa watch</code> is executed, then Mimosa keeps running and monitors the project's codebase for changes. When changes occur, the watch workflows are executed. The watch types are very straight forward.</p><p>For watch types no delineation exists between file and extension. For each type only a single file is processed at a time. So modules like the CSS and micro-templates compilers perform extension-wide tasks based on the single file that was updated.</p><h5>add</h5><p>The <code>add</code> workflow is kicked off when a new file is added to the <code>watch.sourceDir</code> directory.</p><h5>update</h5><p>The <code>update</code> workflow is run when an existing file in the <code>watch.sourceDir</code> directory is saved.</p><h5>remove</h5><p>The <code>remove</code> workflow is executed when a file in the <code>watch.sourceDir</code> directory is deleted.</p></div><div class="col-md-4"><h4>Clean Workflows</h4><p>The clean workflows execute when using <code>mimosa clean</code> (but not currently when <code>--force</code> is used), when the <code>--clean</code> flag is used with <code>mimosa watch</code> and at the beginning of a <code>mimosa build</code>. These workflows are responsible for removing compiled, copied and created assets and to generally return a project to a pre-Mimosa state. The clean workflows are always executed together and in order.</p><p>Modules can create and deposit files during the other workflows. A good module will use the clean workflows to tidy up after itself.</p><h5>preClean</h5><p>The <code>preClean</code> workflow is executed first and is an opportunity to handle files before <code>cleanFile</code> comes through and deals with each file individually.</p><h5>cleanFile</h5><p>Each file in the <code>watch.sourceDir</code> is passed through the <code>cleanFile</code> workflow one at a time.</p><h5>postClean</h5><p>The <code>postClean</code> workflow is the final opportunity to tidy up files and directories. This is when, for example, a module might make a pass to remove any empty directories the module might be responsible for that remain after the files have been handled.</p></div></div><h3>Workflow Steps <small>a list of processing steps for each workflow</small></h3><p>The previous section covered each of the workflows. Each workflow has many steps within it. An example is the best way to illustrate how steps relate to workflows.</p><p>The simplest workflow is <code>update</code>. If a CoffeeScript file is saved inside the <code>watch.sourceDir</code> while Mimosa is running, here is what might happen:</p><ol><li>The first step executed is <code>init</code>. During the <code>init</code> step, Mimosa will generate some information about the asset to be used by future steps. For instance it will set a flag into the <code>options</code> object (discussed in the next section) to indicate that the file is a JavaScript file, and it will set flags to indicate if the file is a vendor file or not.</li><li>During a step named <code>read</code> the modified CoffeeScript file is read in.</li><li>The <code>compile</code> step is next. Here the CoffeeScript gets compiled to JavaScript.</li><li>Next is <code>afterCompile</code>. Here the compiled JavaScript is linted to get feedback regarding code quality.</li><li>If minification was selected, <code>beforeWrite</code> is where the compiled JavaScript would be minified.</li><li>During the <code>write</code> step the compiled JavaScript is written to the <code>watch.compiledDir</code></li><li>The <code>afterWrite</code> step is where optimization takes place if that is selected.</li></ol><p>Also, many modules can register to be executed for the same workflow and step, they'll just be executed in order that they get registered which is determined by their order in the <code>modules</code> array in the <code>mimosa-config</code>.</p><p>When building a module, a developer needs to decide which step is the right place to execute a module's functionality. For instance, if building a module that will run <a href="http://www.coffeelint.org/">CoffeeLint</a> over CoffeeScript to determine CoffeeScript code quality, then <code>afterRead</code> is probably the best step. If, for instance, <code>beforeRead</code> is used, then Mimosa will have not yet read in the file, and there will be nothing on which to run CoffeeLint.</p><h3>Workflow Type & Step Breakdown</h3><div class="btn-group btn-group-justified" role="group" aria-label="Justified button group"><a data-type="build" href="#" class="btn btn-primary active" role="button">Build Workflows</a> <a data-type="watch" href="#" class="btn btn-primary" role="button">Watch Workflows</a> <a data-type="clean" href="#" class="btn btn-primary" role="button">Clean Workflows</a></div><div data-type="build" class="row workflow-steps"><div class="col-md-3"><h4>preBuild</h4><ul><li>init</li><li>complete</li></ul></div><div class="col-md-3"><h4>buildFile</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>betweenReadCompile</li><li>beforeCompile</li><li>compile</li><li>afterCompile</li><li>betweenCompileWrite</li><li>beforeWrite</li><li>write</li><li>afterWrite</li><li>complete</li></ul></div><div class="col-md-3"><h4>buildExtension</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>betweenReadCompile</li><li>beforeCompile</li><li>compile</li><li>afterCompile</li><li>betweenCompileWrite</li><li>beforeWrite</li><li>write</li><li>afterWrite</li><li>complete</li></ul></div><div class="col-md-3"><h4>postBuild</h4><ul><li>init</li><li>beforeOptimize</li><li>optimize</li><li>afterOptimize</li><li>beforeServer</li><li>server</li><li>afterServer</li><li>beforePackage</li><li>package</li><li>afterPackage</li><li>beforeInstall</li><li>install</li><li>afterInstall</li><li>complete</li></ul></div></div><div data-type="watch" class="row workflow-steps hide"><div class="col-md-4"><h4>add</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>betweenReadCompile</li><li>beforeCompile</li><li>compile</li><li>afterCompile</li><li>betweenCompileWrite</li><li>beforeWrite</li><li>write</li><li>afterWrite</li><li>betweenWriteOptimize</li><li>beforeOptimize</li><li>optimize</li><li>afterOptimize</li><li>complete</li></ul></div><div class="col-md-4"><h4>update</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>betweenReadCompile</li><li>beforeCompile</li><li>compile</li><li>afterCompile</li><li>betweenCompileWrite</li><li>beforeWrite</li><li>write</li><li>afterWrite</li><li>betweenWriteOptimize</li><li>beforeOptimize</li><li>optimize</li><li>afterOptimize</li><li>complete</li></ul></div><div class="col-md-4"><h4>remove</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>beforeDelete</li><li>delete</li><li>afterDelete</li><li>beforeCompile</li><li>compile</li><li>afterCompile</li><li>betweenCompileWrite</li><li>beforeWrite</li><li>write</li><li>afterWrite</li><li>betweenWriteOptimize</li><li>beforeOptimize</li><li>optimize</li><li>afterOptimize</li><li>complete</li></ul></div></div><div data-type="clean" class="row workflow-steps hide"><div class="col-md-4"><h4>preClean</h4><ul><li>init</li><li>complete</li></ul></div><div class="col-md-4"><h4>cleanFile</h4><ul><li>init</li><li>beforeRead</li><li>read</li><li>afterRead</li><li>beforeDelete</li><li>delete</li><li>afterDelete</li><li>complete</li></ul></div><div class="col-md-4"><h4>postClean</h4><ul><li>init</li><li>complete</li></ul></div></div></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="execution">Module Execution</h2></div><div class="panel-body"><p>So a module's code is registered to be called in the right spot in the workflow. What happens when Mimosa calls the function that has been registered?</p><p>The executed function is handed three arguments.</p><ol><li><code>mimosaConfig</code>: The full <code>mimosa-config</code> enriched with all sorts of useful data beyond the default <code>mimosa-config</code>, and including the configuration for the module being developed.</li><li><code>options</code>: An object containing information about the asset(s)/extension currently being processed. At different steps of the a Mimosa workflow the options object will contain various important pieces of information. One of the first steps a module developer should take when developing a new module is to <code>console.log</code> the content of the options object to see what sort of information is available at their desired workflow and workflow step.</li><li><code>next</code>: a workflow callback. This callback must be called when a module has finished processing. It tells Mimosa to execute the next step in the workflow. If for some reason a module decides that processing for the current asset/build step needs to stop, the callback can be called passing false. Ex: <code>next(false)</code>. In most cases the workflow should not be ended prematurely.</li></ol></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="commands">Adding New Commands: Command Modules</h2></div><div class="panel-body"><p>A command module has a very simple interface. A module that intends to implement a new command needs to implement and export a <code>registerCommand</code> function. That function takes a <a href="https://github.com/visionmedia/commander.js/">commander</a> <code>program</code>object for registering the command, the flags, the help text and a callback.</p><p>If a function needs access to execute a <code>build</code> before running, or needs the <code>mimosa-config</code>, it can get accomplish those things using the second parameter passed to <code>registerCommand</code>. The second parameter, a <code>retrieveConfig</code> function, takes a flag indicating if a build is needed, and a callback. That callback should contain the command module's code, and it is passed the full <code>mimosa-config</code>.</p><p>For interface details, see the <a href="#interface">interface section above</a>.</p></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="logging">Module Logging</h2></div><div class="panel-body"><p>Mimosa's logger, <a href="https://github.com/dbashford/logmimosa">logmimosa</a>, is attached to the resolved <code>mimosaConfig</code> when Mimosa starts up. Every function in a module that Mimosa calls and includes the <code>mimosaConfig</code>, like the workflow functions, <code>registration</code> or <code>registerCommand</code>, can access the logger via <code>mimosaConfig.log</code>.</p><p>To take advantage of Mimosa's colorizing, wrap important or variable parts of log messages in <code>[[</code> and <code>]]</code>.</p></div></div><div class="panel panel-default"><div class="panel-heading large-heading"><h2 id="install">Installing Modules</h2></div><div class="panel-body"><h3>During Development</h3><p>The <code>mimosa mod:install</code> command handles installing local modules to Mimosa. From inside the root module directory, the directory with the <code>package.json</code> file, execute <code>mimosa mod:install</code>. Then modify the modules array of a project's <code>mimosa-config</code> to use the module. Fire up Mimosa and test your module out!</p><h3>Publishing to NPM</h3><p>If you are familiar with <a href="http://npmjs.org/">NPM</a>, this part is not new. A simple <code>npm publish</code> from the root of your module will install a module to NPM so that anyone can get access to it. Once it is in NPM, commands like <code>mod:install</code> and <code>mod:list</code> will be able to find it.</p><p>If you have never published to NPM before, then spend a few minutes reading the <a href="https://npmjs.org/doc/developers.html">developer docs</a>. Just a few simple steps and you are ready to publish.</p><p>If you do create and publish a module, let us know!!!</p></div></div></div></div></div><div class="container-fluid"><footer><div class="container"><ul><li><iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=dbashford&repo=mimosa&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="112px" height="20px"></iframe></li><li><iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=dbashford&repo=mimosa&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="98px" height="20px"></iframe></li><li class="follow-btn"><a href="https://twitter.com/mimosajs" class="twitter-follow-button" data-link-color="#0069D6" data-show-count="true">Follow @mimosajs</a></li><li class="tweet-btn"><a href="https://twitter.com/share" data-text="Mimosa - A lightning-fast build tool for modern web development" class="twitter-share-button" data-url="http://mimosa.io" data-count="horizontal" data-via="mimosajs">Tweet</a></li></ul><ul><li>Current Version v3.0.0</li><li>-</li><li><a href="https://github.com/dbashford/mimosa/blob/master/RELEASENOTES.md">Release Notes</a></li><li>-</li><li><a href="https://github.com/dbashford/mimosa">GitHub</a></li><li>-</li><li><a href="https://github.com/dbashford/mimosa/issues">Issues</a></li><li>-</li><li><a href="https://gitter.im/dbashford/mimosa">Chat</a></li><li>-</li><li><a href="https://groups.google.com/forum/#!forum/mimosajs">Google Group</a></li></ul></div></footer></div><script src="http://code.jquery.com/jquery-2.1.3.min.js"></script><script src="public/javascripts/vendor/bootstrap.min.js"></script><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script><script>var _gaq=[['_setAccount','UA-33737130-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));</script><script>var workflowButtons = $('.btn-group a')
    var workflowDetails = $('.workflow-steps');
    $(workflowButtons).click(function(e) {
      e.preventDefault();
      $(workflowButtons).removeClass('active');
      $(this).addClass('active');
      var type = $(this).attr('data-type');
      $(workflowDetails).addClass('hide');
      $('div[data-type=' + type + ']').removeClass('hide')
    });</script></body></html>